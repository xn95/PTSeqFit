#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 1.0.5 on Wed Apr  2 16:55:08 2025
#

import wx
import os
import xrayutilities as xu
import numpy as np
from threading import Thread
from scipy.optimize import least_squares, Bounds
from xrayutilities.materials.spacegrouplattice import sgrp_name
import EoS_dictionaries as EoS
from PVT import BM
import matplotlib

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg as NavigationToolbar2Wx
matplotlib.use('WXAgg')
import matplotlib.pyplot as plt

"""
FUNCTION BLOCK
"""

def poni2wave(poni):#read a wavelength in angstroms from a .poni calibration file
    with open(poni) as file:
        wavelength = [i.split()[1] for i in file if i.split()[0] == "Wavelength:"]
    return float(wavelength[0])*10000000000

def open_dat(filename):#read file with x,y values per line
    with open(filename) as dat:
        temp = [i.split(" ") for i in dat]
        for i in temp:
            i[0] = float(i[0])
            i[1] = float(i[1])
        out = [i for i in temp]
    return out

def data2slices(data_2theta, theta_peak_guess, theta_variance): #creates a data slice about each peak position
    sliced_data = []
    for i in theta_peak_guess:
        # we can assume a peak will never lie on a datum, so we take the point directly above and below the peak, add theta_variance peaks on either side
        nearest_below = [xy for xy in data_2theta if xy[0] < i][-1]
        nearest_above = [xy for xy in data_2theta if xy[0] > i][0]
        lower_half_slice = data_2theta[data_2theta.index(nearest_below)-theta_variance:data_2theta.index(nearest_below)]
        upper_half_slice = data_2theta[data_2theta.index(nearest_above):data_2theta.index(nearest_above)+theta_variance]
        data_slice = lower_half_slice + upper_half_slice
        sliced_data.append(data_slice)
    return sliced_data

def gauss(x, amp, cen, sigma, shift):#basic gaussian function
    return amp * np.exp(-(x-cen)**2 / (2.*sigma**2)) + shift

def split_model(i, region, gaussian_params, peaks):#takes a data slice and draws a gaussian over the slice 
    amps = gaussian_params[0:len(peaks)]
    sigmas = gaussian_params[len(peaks):(2*len(peaks))]
    shifts = gaussian_params[2*len(peaks):]
    peak_pos = peaks[i]
    amp = amps[i]
    sigma = sigmas[i]
    shift = shifts[i]

    x_values = [xy[0] for xy in region]
    y_obs = [xy[1] for xy in region]
    y_calc = gauss(x_values, amp, peak_pos, sigma, shift)
    y_diff = [abs(a - b) for a,b in zip(y_obs, y_calc)]
    return x_values, y_calc, y_diff

def fit_function(parameters, SG_num, ttheta_max, wavelength, data_file, theta_variance, num_peaks):
    #fitting function for use in LS, requires a 1D array of residuals to be output
    #get the data into list of [x,y]s
    data_2theta = open_dat(data_file)
    
    #seperate parameters list into gaussian params and lattice params
    gaussian_params = parameters[0:3*num_peaks]
    lattice_params = parameters[len(gaussian_params):]
    
    #generate peaks in 2theta:
    material = xu.materials.Crystal("material", xu.materials.SGLattice(int(SG_num), *[float(i) for i in lattice_params]))
    indexing_info = xu.simpack.PowderDiffraction(material, tt_cutoff = ttheta_max+5, enable_simulation = False, wl = wavelength).data
    peak_list = []
    for key in indexing_info.keys():
        peak_pos = indexing_info[key]["ang"]*2
        peak_list.append(peak_pos)
    peak_list = peak_list[:num_peaks]
        
    #cut data into regions about peaks:
    regions = data2slices(data_2theta, peak_list, theta_variance)

    #do gaussian model and get difference between y_obs and y_calc for each region
    residual_total = []

    for i, region in enumerate(regions):
        x_values, y_calc, y_diff = split_model(i, region, gaussian_params, peak_list)
        residual_total.extend(y_diff)
    
    return np.array(residual_total)
    
def plot_fit_function(parameters, SG_num, ttheta_max, wavelength, data_file, theta_variance, num_peaks):
    #similar to above function but generates a matplotlib figure of a fit
    #get the data into list of [x,y]s
    data_2theta = open_dat(data_file)
    
    #seperate parameters list into gaussian params and lattice params
    gaussian_params = parameters[0:3*num_peaks]
    lattice_params = parameters[len(gaussian_params):]
    #generate peaks in 2theta:
    material = xu.materials.Crystal("material", xu.materials.SGLattice(int(SG_num), *[float(i) for i in lattice_params]))
    indexing_info = xu.simpack.PowderDiffraction(material, tt_cutoff = ttheta_max+5, enable_simulation = False, wl = wavelength).data
    
    peak_list = []
    for key in indexing_info.keys():
        peak_pos = indexing_info[key]["ang"]*2
        peak_list.append(peak_pos)
    peak_list = peak_list[:num_peaks]
    #cut data into regions about peaks:
    regions = data2slices(data_2theta, peak_list, theta_variance)

    #do gaussian model and get difference between y_obs and y_calc for each region
    
    fig, ax = plt.subplots(dpi = 100)
    for region in regions:
        i = regions.index(region)
        x_values, y_calc, y_diff = split_model(i, region, gaussian_params, peak_list)
        ax.scatter([i[0] for i in data_2theta], [i[1] for i in data_2theta], s = 2, color = "k")
        max_int = max([i[1] for i in data_2theta])
        ax.plot(x_values, y_calc, color = "r", label = "fit")
        ax.plot(x_values, [y-(0.1*max_int) for y in y_diff], color = "b", label = "difference")
        if i == 0:
            ax.legend()
        else:
            pass
    ax.set_xlabel = "2theta (°)"
    ax.set_ylabel = "Intensity (arb. units)"
    return fig

def do_fit(fit_function, params, bounds, SG_num, ttheta_max, wavelength, initial_data_file, theta_variance, num_peaks):
    #wrapper for convienience
    out = least_squares(fit_function, params, bounds = bounds, args = (SG_num, ttheta_max, wavelength, initial_data_file, theta_variance, num_peaks))
    return out

def cif2material(cif_path):
    #takes .cif and uses xu to generate a lattice
    material = xu.materials.Crystal.fromCIF(cif_path)
    SGLattice_object = material.lattice
    return material, SGLattice_object

def SG_lattice_params2material(SG_num, in_lattice_params):
    #similar to aboce but uses a list of lattice parameters and a SG number to generate an object for indexing
    material = xu.materials.Crystal("material", xu.materials.SGLattice(int(SG_num), *[float(i) for i in in_lattice_params]))
    SGLattice_object = material.lattice
    return material, SGLattice_object

def SG_lattice_object_read(SGLattice_object):
    SG_num = SGLattice_object.space_group_nr
    lattice_params = []
    if SGLattice_object.crystal_system == "cubic":
        lattice_params = [SGLattice_object.a]

    if SGLattice_object.crystal_system == "hexagonal":
        lattice_params = [SGLattice_object.a, SGLattice_object.b]
        
    if SGLattice_object.crystal_system == "trigonal":
        lattice_params = [SGLattice_object.a, SGLattice_object.b]
        
    if SGLattice_object.crystal_system == "tetragonal":
        lattice_params = [SGLattice_object.a, SGLattice_object.b]

    if SGLattice_object.crystal_system == "orthorhombic":
        lattice_params = [SGLattice_object.a, SGLattice_object.b, SGLattice_object.c]

    if SGLattice_object.crystal_system == "monoclinic":
        lattice_params = [SGLattice_object.a, SGLattice_object.b, SGLattice_object.c, SGLattice_object.beta]

    if SGLattice_object.crystal_system == "triclinic":
        lattice_params = [SGLattice_object.a, SGLattice_object.b, SGLattice_object.c, SGLattice_object.alpha, SGLattice_object.beta, SGLattice_object.gamma]
    return SG_num, lattice_params

def lattice2volume(SG_num, lattice_params):
    if SG_num <= 230 and SG_num > 194:#cubic
        volume = lattice_params[0]**3
    if SG_num < 195 and SG_num > 142:#hexagonal,trigonal
        volume = np.sin(60*(np.pi/180))*lattice_params[1]*lattice_params[0]**2
    if SG_num < 143 and SG_num > 74:#tetragonal
        volume = lattice_params[1]*lattice_params[0]**2
    if SG_num < 75 and SG_num > 15:#ortho
        volume = lattice_params[0]*lattice_params[1]*lattice_params[2]
    if SG_num < 16 and SG_num > 2:#mono
        volume = lattice_params[0]*lattice_params[1]*lattice_params[2] * np.sin(lattice_params[3]*(np.pi/180))
    if SG_num < 3:#triclinic
        volume = lattice_params[0]*lattice_params[1]*lattice_params[2]*(1- np.cos(lattice_params[3]*(np.pi/180))**2 - np.cos(lattice_params[4]*(np.pi/180))**2 - np.cos(lattice_params[5]*(np.pi/180))**2) + 2*(np.cos(lattice_params[3]*(np.pi/180))*np.cos(lattice_params[4]*(np.pi/180))*np.cos(lattice_params[5]*(np.pi/180)))**0.5
    return volume

def generate_LSparams(gauss_params, lattice_params):
    initial_params = gauss_params + lattice_params
    lower_bounds = [0 for i in initial_params]
    upper_bounds = [np.inf for i in initial_params]
    bounds = Bounds(lb = lower_bounds, ub = upper_bounds)
    return initial_params, bounds,

"""
GUI BLOCK
generated from wxGlade
"""

class Main_window(wx.Frame):
    def __init__(self, *args, **kwds):
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetTitle("PTSFit - Pressure, Temperature from Sequential Fits")
        icon = wx.EmptyIcon()
        icon.CopyFromBitmap(wx.Bitmap("icon.ico", wx.BITMAP_TYPE_ANY))
        self.SetIcon(icon)
        self.panel_1 = wx.Panel(self, wx.ID_ANY)

        main_sizer = wx.BoxSizer(wx.VERTICAL)

        sizer_26 = wx.BoxSizer(wx.HORIZONTAL)
        main_sizer.Add(sizer_26, 1, wx.EXPAND, 0)

        sizer_27 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "Data Fitting"), wx.VERTICAL)
        sizer_26.Add(sizer_27, 0, wx.EXPAND, 0)

        sizer_30 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "File I/O"), wx.VERTICAL)
        sizer_27.Add(sizer_30, 0, 0)

        sizer_34 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_30.Add(sizer_34, 0, wx.EXPAND, 0)

        self.button_open_calib = wx.Button(self.panel_1, wx.ID_ANY, "Open calibration file", style=wx.BU_EXACTFIT)
        sizer_34.Add(self.button_open_calib, 0, wx.EXPAND, 0)

        label_18 = wx.StaticText(self.panel_1, wx.ID_ANY, u" or, specify wavelength (Å):")
        sizer_34.Add(label_18, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_wavelength = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_34.Add(self.text_ctrl_wavelength, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        sizer_35 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_30.Add(sizer_35, 1, wx.EXPAND, 0)

        self.button_open_datafiles = wx.Button(self.panel_1, wx.ID_ANY, "Open datafiles", style=wx.BU_EXACTFIT)
        sizer_35.Add(self.button_open_datafiles, 0, wx.EXPAND, 0)

        sizer_36 = wx.BoxSizer(wx.VERTICAL)
        sizer_35.Add(sizer_36, 1, wx.EXPAND, 0)

        label_19 = wx.StaticText(self.panel_1, wx.ID_ANY, "Loaded datafiles:")
        sizer_36.Add(label_19, 0, 0, 0)

        self.list_box_1 = wx.ListBox(self.panel_1, wx.ID_ANY, choices=[], style=wx.LB_ALWAYS_SB | wx.LB_SINGLE)
        sizer_36.Add(self.list_box_1, 0, wx.EXPAND, 0)

        label_20 = wx.StaticText(self.panel_1, wx.ID_ANY, "Sequential fit proceeds in above order")
        sizer_36.Add(label_20, 0, 0, 0)
        
        self.button_plot_datafile = wx.Button(self.panel_1, wx.ID_ANY, "Plot selected datafile", style=wx.BU_EXACTFIT)
        sizer_36.Add(self.button_plot_datafile, 0, 0, 0)
        self.button_plot_datafile.Disable()

        sizer_31 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "Crystal Parameters"), wx.VERTICAL)
        sizer_27.Add(sizer_31, 0, wx.EXPAND, 0)

        sizer_37 = wx.BoxSizer(wx.VERTICAL)
        sizer_31.Add(sizer_37, 1, 0)

        sizer_41 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_37.Add(sizer_41, 1, wx.EXPAND, 0)

        self.button_open_cif = wx.Button(self.panel_1, wx.ID_ANY, "Open .cif")
        sizer_41.Add(self.button_open_cif, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        label_21 = wx.StaticText(self.panel_1, wx.ID_ANY, "Space group number:")
        sizer_41.Add(label_21, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_SG_num = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_41.Add(self.text_ctrl_SG_num, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.label_SG_name = wx.StaticText(self.panel_1, wx.ID_ANY, "")
        sizer_41.Add(self.label_SG_name, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        sizer_38 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_37.Add(sizer_38, 1, wx.EXPAND, 0)

        label_23 = wx.StaticText(self.panel_1, wx.ID_ANY, u"a (Å):")
        sizer_38.Add(label_23, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_a = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_38.Add(self.text_ctrl_a, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        label_26 = wx.StaticText(self.panel_1, wx.ID_ANY, u"alpha (Å):")
        sizer_38.Add(label_26, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_alpha = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_38.Add(self.text_ctrl_alpha, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        sizer_39 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_37.Add(sizer_39, 1, wx.EXPAND, 0)

        label_24 = wx.StaticText(self.panel_1, wx.ID_ANY, u"b (Å):")
        sizer_39.Add(label_24, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_b = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_39.Add(self.text_ctrl_b, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        label_27 = wx.StaticText(self.panel_1, wx.ID_ANY, u"beta (Å):")
        sizer_39.Add(label_27, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_beta = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_39.Add(self.text_ctrl_beta, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        sizer_40 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_37.Add(sizer_40, 1, wx.EXPAND, 0)

        label_25 = wx.StaticText(self.panel_1, wx.ID_ANY, u"c (Å):")
        sizer_40.Add(label_25, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_c = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_40.Add(self.text_ctrl_c, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        label_28 = wx.StaticText(self.panel_1, wx.ID_ANY, u"gamma (Å):")
        sizer_40.Add(label_28, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_gamma = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_40.Add(self.text_ctrl_gamma, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_a.SetEditable(False)
        self.text_ctrl_b.SetEditable(False)
        self.text_ctrl_c.SetEditable(False)
        self.text_ctrl_alpha.SetEditable(False)
        self.text_ctrl_beta.SetEditable(False)
        self.text_ctrl_gamma.SetEditable(False)

        sizer_32 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "Gaussian Parameters"), wx.VERTICAL)
        sizer_27.Add(sizer_32, 0, wx.EXPAND, 0)

        label_29 = wx.StaticText(self.panel_1, wx.ID_ANY, "Rough parameters for gaussian fitting:")
        sizer_32.Add(label_29, 0, 0, 0)

        sizer_42 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_32.Add(sizer_42, 1, wx.EXPAND, 0)

        label_30 = wx.StaticText(self.panel_1, wx.ID_ANY, "Scale (amplitude):")
        sizer_42.Add(label_30, 0, 0, 0)

        self.text_ctrl_scale = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_42.Add(self.text_ctrl_scale, 0, 0, 0)

        sizer_43 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_32.Add(sizer_43, 1, wx.EXPAND, 0)

        label_31 = wx.StaticText(self.panel_1, wx.ID_ANY, "Sigma (FWHM):")
        sizer_43.Add(label_31, 0, 0, 0)

        self.text_ctrl_sigma = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_43.Add(self.text_ctrl_sigma, 0, 0, 0)

        sizer_44 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_32.Add(sizer_44, 1, wx.EXPAND, 0)

        label_32 = wx.StaticText(self.panel_1, wx.ID_ANY, "Shift (background):")
        sizer_44.Add(label_32, 0, 0, 0)

        self.text_ctrl_shift = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_44.Add(self.text_ctrl_shift, 0, 0, 0)

        sizer_33 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "Fit Control"), wx.VERTICAL)
        sizer_27.Add(sizer_33, 0, wx.EXPAND, 0)

        sizer_45 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_33.Add(sizer_45, 1, wx.EXPAND, 0)

        label_33 = wx.StaticText(self.panel_1, wx.ID_ANY, u"Maximum 2theta for indexing (°):")
        sizer_45.Add(label_33, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_max_2theta = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_45.Add(self.text_ctrl_max_2theta, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        sizer_46 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_33.Add(sizer_46, 1, wx.EXPAND, 0)

        label_34 = wx.StaticText(self.panel_1, wx.ID_ANY, "Data to fit gaussian about each peak (°):")
        sizer_46.Add(label_34, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        
        self.text_ctrl_variance = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_46.Add(self.text_ctrl_variance, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        
        label_134 = wx.StaticText(self.panel_1, wx.ID_ANY, "(Reduce this value to avoid fitting overlapping peaks)")
        sizer_33.Add(label_134, 0,0)

        sizer_47 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_33.Add(sizer_47, 1, wx.EXPAND, 0)

        label_36 = wx.StaticText(self.panel_1, wx.ID_ANY, "Maximum datafiles to fit (n):")
        sizer_47.Add(label_36, 0, wx.ALIGN_CENTER_VERTICAL, 0)

        self.text_ctrl_final_file_num = wx.TextCtrl(self.panel_1, wx.ID_ANY, "")
        sizer_47.Add(self.text_ctrl_final_file_num, 0, 0, 0)

        self.button_do_seq_fit = wx.Button(self.panel_1, wx.ID_ANY, "Do sequential fit(s)")
        sizer_33.Add(self.button_do_seq_fit, 0,  wx.EXPAND, 0)

        self.gauge_1 = wx.Gauge(self.panel_1, wx.ID_ANY, 100)
        sizer_27.Add(self.gauge_1, 0, wx.EXPAND, 0)

        sizer_28 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "PVT Fitting"), wx.VERTICAL)
        sizer_26.Add(sizer_28, 1, wx.EXPAND, 0)

        self.PVT_table = wx.ListCtrl(self.panel_1, wx.ID_ANY, style=wx.LC_HRULES | wx.LC_REPORT | wx.LC_VRULES)
        self.PVT_table.AppendColumn("Filename", width = 200)
        self.PVT_table.AppendColumn(u"Volume (Å^3)", width = 200)
        self.PVT_table.AppendColumn("Pressure (GPa)", width = 100)
        self.PVT_table.AppendColumn("Temperature (K)", width = 100)
        self.PVT_table.SetMinSize((800, 400))
        sizer_28.Add(self.PVT_table, 0, wx.EXPAND | wx.SHAPED, 0)

        sizer_29 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_28.Add(sizer_29, 1, wx.EXPAND, 0)

        self.CB_select_EoS_params = wx.ComboBox(self.panel_1, wx.ID_ANY, "Built-in EoS parameters", choices = [i["name"] for i in EoS.dictionaries], style = wx.CB_DROPDOWN | wx.CB_READONLY)
        sizer_29.Add(self.CB_select_EoS_params, 0, wx.ALL, 0)

        self.btn_import_EoS = wx.Button(self.panel_1, wx.ID_ANY, "Specify EoS Parameters")
        sizer_29.Add(self.btn_import_EoS, 0, 0, 0)

        self.btn_do_PVT = wx.Button(self.panel_1, wx.ID_ANY, "Determine P,T from EoS")
        sizer_29.Add(self.btn_do_PVT, 0, 0, 0)
        self.btn_do_PVT.Disable()

        self.btn_plot_PVT = wx.Button(self.panel_1, wx.ID_ANY, "Plot PVT")
        sizer_29.Add(self.btn_plot_PVT, 0, 0, 0)

        self.btn_save_PVT = wx.Button(self.panel_1, wx.ID_ANY, "Save PVT as .csv")
        sizer_29.Add(self.btn_save_PVT, 0, 0, 0)

        sizer_25 = wx.StaticBoxSizer(wx.StaticBox(self.panel_1, wx.ID_ANY, "Log Console:"), wx.HORIZONTAL)
        main_sizer.Add(sizer_25, 1, wx.EXPAND, 0)

        self.log = wx.TextCtrl(self.panel_1, wx.ID_ANY, "", style=wx.TE_MULTILINE | wx.TE_READONLY)
        self.log.SetMinSize((800, 240))
        sizer_25.Add(self.log, 1, wx.EXPAND | wx.FIXED_MINSIZE, 0)
        
        self.log.WriteText("Program by Sean Injac, PVT parameter functions adopted from Sokolova et al: https://doi.org/10.1016/j.cageo.2016.06.002\n")
        self.log.WriteText("Python errors will print to console, not here\n")

        self.panel_1.SetSizer(main_sizer)

        main_sizer.Fit(self)
        self.Layout()

        self.Bind(wx.EVT_BUTTON, self.open_datafiles, self.button_open_datafiles)
        self.Bind(wx.EVT_BUTTON, self.open_calibration, self.button_open_calib)
        self.Bind(wx.EVT_LISTBOX, self.file_highlight, self.list_box_1)
        self.Bind(wx.EVT_BUTTON, self.datafile_plot, self.button_plot_datafile)
        self.Bind(wx.EVT_BUTTON, self.open_cif, self.button_open_cif)

        self.Bind(wx.EVT_TEXT, self.SG_input, self.text_ctrl_SG_num)
        self.Bind(wx.EVT_TEXT, self.a_input, self.text_ctrl_a)
        self.Bind(wx.EVT_TEXT, self.alpha_input, self.text_ctrl_alpha)
        self.Bind(wx.EVT_TEXT, self.b_input, self.text_ctrl_b)
        self.Bind(wx.EVT_TEXT, self.beta_input, self.text_ctrl_beta)
        self.Bind(wx.EVT_TEXT, self.c_input, self.text_ctrl_c)

        self.Bind(wx.EVT_TEXT, self.gamma_input, self.text_ctrl_gamma)
        self.Bind(wx.EVT_TEXT, self.scale_input, self.text_ctrl_scale)
        self.Bind(wx.EVT_TEXT, self.sigma_input, self.text_ctrl_sigma)
        self.Bind(wx.EVT_TEXT, self.shift_input, self.text_ctrl_shift)
        self.Bind(wx.EVT_TEXT, self.theta_variance2datapoints, self.text_ctrl_variance)
        self.Bind(wx.EVT_TEXT, self.input_max_ttheta, self.text_ctrl_max_2theta)
        self.Bind(wx.EVT_TEXT, self.fit_final_num_in, self.text_ctrl_final_file_num)
        #self.Bind(wx.EVT_BUTTON, self.do_seq_fit, self.button_do_seq_fit) <-- if not using threading
        self.Bind(wx.EVT_BUTTON, self.do_seq_threaded, self.button_do_seq_fit)
        self.Bind(wx.EVT_TEXT, self.wavelength_input, self.text_ctrl_wavelength)
        self.Bind(wx.EVT_COMBOBOX, self.calibrant_load, self.CB_select_EoS_params)
        self.Bind(wx.EVT_BUTTON, self.do_PVT, self.btn_do_PVT)
        self.Bind(wx.EVT_BUTTON, self.EoS_dialog, self.btn_import_EoS)
        self.Bind(wx.EVT_BUTTON, self.plot_PVT, self.btn_plot_PVT)
        self.Bind(wx.EVT_BUTTON, self.save_PVT, self.btn_save_PVT)
        self.Bind(wx.EVT_LIST_ITEM_RIGHT_CLICK, self.PVT_right_click, self.PVT_table)
        
        #initialising some variables
        self.loaded_calibrant = None
        self.loaded_calibrant_dicts = EoS.dictionaries
        self.gaussian_params = [0,0,0]
        self.SG_num = None
        self.lattice_params = ["","","","","",""]
        self.loaded_datafiles = []
        self.selected_datafile = None
        self.max_2theta = None
        self.max_dataframe = None
        self.wavelength = None
        self.refined_datasets = []
        self.fit_window_size = int(0)
    
    def spawn_plot(self, fig, name):#general function to spawn a plot window
        frame = Plotframe(self, name, fig)
        frame.Show(True)
        return True
    
    def wavelength_input(self, event):#if user inputs wavelength
        try:
            self.wavelength = float(self.text_ctrl_wavelength.GetValue())
        except ValueError:
            return None
        
    def open_calibration(self, event):#open a .poni
        wildcard = "poni file (*.poni)|*.poni|"     \
           "All files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Select calibration file",
            defaultDir=os.getcwd(),
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN |
                  wx.FD_CHANGE_DIR | wx.FD_FILE_MUST_EXIST |
                  wx.FD_PREVIEW
            )
        if dlg.ShowModal() == wx.ID_OK:
            self.loaded_poni = dlg.GetPaths()[0]
            self.wavelength = poni2wave(self.loaded_poni)
            self.text_ctrl_wavelength.SetValue(str(self.wavelength))
            self.log.WriteText('Wavelength from calibration file = ' + str(self.wavelength)+u" Å"+"\n")
        else:
            self.log.WriteText("Please select a valid file")
            
        dlg.Destroy()
        #update GUI and class variable
        
        
    def open_datafiles(self, event):  #opening datafiles
        wildcard = "Dioptas dat file (*.dat)|*.dat|"     \
           "Other space seperated xy files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Select Datafiles",
            defaultDir=os.getcwd(),
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN | wx.FD_MULTIPLE |
                  wx.FD_CHANGE_DIR | wx.FD_FILE_MUST_EXIST |
                  wx.FD_PREVIEW
            )
        if dlg.ShowModal() == wx.ID_OK:
            names =[]
            self.loaded_datafiles += dlg.GetPaths()
            names = [os.path.split(path)[1] for path in self.loaded_datafiles]
            self.log.WriteText('Imported %d file(s):\n' % len(names))
            for name in names:
                self.log.WriteText('           %s\n' % name)
            self.list_box_1.AppendItems(names)
            self.max_dataframe = len(self.loaded_datafiles)
            self.text_ctrl_final_file_num.SetValue(str(self.max_dataframe))
            last_dataset = open_dat(self.loaded_datafiles[-1])
            max_2theta = float(max([i[0] for i in last_dataset]))
            self.text_ctrl_max_2theta.SetValue(str(max_2theta))
        
        dlg.Destroy()
        #get an estimate for max 2theta by taking the maximum x value of the last dataset:
        


    def file_highlight(self, event):  # need to know what files get selected
        name_index = self.list_box_1.GetSelection()
        self.selected_datafile = self.loaded_datafiles[name_index]
        self.button_plot_datafile.Enable()
        
    def datafile_plot(self, event):#quick plot of raw data
        filename = self.selected_datafile
        loaded_data = open_dat(filename)#[[x,y],]
        x = [i[0] for i in loaded_data]
        y = [i[1] for i in loaded_data]
        fig, ax = plt.subplots(dpi = 100)
        ax.plot(x,y)
        ax.set_ylabel("Counts (n)")
        ax.set_xlabel("2theta (°)")
        name = os.path.split(filename)[1]
        self.spawn_plot(fig, name)

    def open_cif(self, event):  # opens a .cif
        wildcard = "cif file (*.cif)|*.cif|"     \
           "All files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Select cif file",
            defaultDir=os.getcwd(),
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN |
                  wx.FD_CHANGE_DIR | wx.FD_FILE_MUST_EXIST |
                  wx.FD_PREVIEW
            )
        if dlg.ShowModal() == wx.ID_OK:
            self.loaded_cif = dlg.GetPaths()
            self.log.WriteText('Imported .cif: ' + str(self.loaded_cif[0])+"\n")
            material, self.SGLattice_object = cif2material(self.loaded_cif[0])
            self.SG_num, self.lattice_params = SG_lattice_object_read(self.SGLattice_object)
            self.text_ctrl_SG_num.SetValue(str(self.SG_num))#this triggers the event associated with this GUI element
        dlg.Destroy()
        
        
    def update_lattice_params(self):#just following some crystallography rules
        try:
            if self.SG_num <= 230 and self.SG_num > 194:#cubic
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_alpha.SetValue(str(90))
                self.text_ctrl_beta.SetValue(str(90))
                self.text_ctrl_gamma.SetValue(str(90))
            if self.SG_num < 195 and self.SG_num > 142:#hexagonal,trigonal,,
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[1]))
                self.text_ctrl_alpha.SetValue(str(90))
                self.text_ctrl_beta.SetValue(str(90))
                self.text_ctrl_gamma.SetValue(str(120))
            if self.SG_num < 143 and self.SG_num > 74:#tetragonal
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[1]))
                self.text_ctrl_alpha.SetValue(str(90))
                self.text_ctrl_beta.SetValue(str(90))
                self.text_ctrl_gamma.SetValue(str(90))
            if self.SG_num < 75 and self.SG_num > 15:#ortho
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[1]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[2]))
                self.text_ctrl_alpha.SetValue(str(90))
                self.text_ctrl_beta.SetValue(str(90))
                self.text_ctrl_gamma.SetValue(str(90))
            if self.SG_num < 16 and self.SG_num > 2:#mono
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[1]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[2]))
                self.text_ctrl_alpha.SetValue(str(90))
                self.text_ctrl_beta.SetValue(str(self.lattice_params[3]))
                self.text_ctrl_gamma.SetValue(str(90))
            if self.SG_num < 3:#triclinic
                self.text_ctrl_a.SetValue(str(self.lattice_params[0]))
                self.text_ctrl_b.SetValue(str(self.lattice_params[1]))
                self.text_ctrl_c.SetValue(str(self.lattice_params[2]))
                self.text_ctrl_alpha.SetValue(str(self.lattice_params[3]))
                self.text_ctrl_beta.SetValue(str(self.lattice_params[4]))
                self.text_ctrl_gamma.SetValue(str(self.lattice_params[5]))
        except TypeError:
            pass
        
            
    def read_lattice(self):#creates a lattice parameter list from the GUI
    #as these are passed to xu's materials object as args the lists should be of variable length based on crystallography
        try:
            if self.SG_num <= 230 and self.SG_num > 194:#cubic
                lattice_params = [float(self.text_ctrl_a.GetValue())
                              ]
            if self.SG_num < 195 and self.SG_num > 74:#hexagonal,trigonal,tetragonal,
                lattice_params = [float(self.text_ctrl_a.GetValue()),
                              float(self.text_ctrl_c.GetValue())
                              ]
            if self.SG_num < 75 and self.SG_num > 15:#ortho
                lattice_params = [float(self.text_ctrl_a.GetValue()),
                              float(self.text_ctrl_b.GetValue()),
                              float(self.text_ctrl_c.GetValue())
                              ]
            if self.SG_num < 16 and self.SG_num > 2:#mono
                lattice_params = [float(self.text_ctrl_a.GetValue()),
                              float(self.text_ctrl_b.GetValue()),
                              float(self.text_ctrl_c.GetValue()),
                              float(self.text_ctrl_beta.GetValue())
                              ]
            if self.SG_num < 3:#triclinic
                lattice_params = [float(self.text_ctrl_a.GetValue()),
                              float(self.text_ctrl_b.GetValue()),
                              float(self.text_ctrl_c.GetValue()),
                              float(self.text_ctrl_beta.GetValue()),
                              float(self.text_ctrl_beta.GetValue()),
                              float(self.text_ctrl_beta.GetValue())
                              ]
            return lattice_params
        except ValueError:
            pass
        
    def SG_input(self, event):  # disables/enables GUI elements based on symmetry
        try:
            self.SG_num = int(self.text_ctrl_SG_num.GetValue())
        except:
            self.log.WriteText("Please enter a valid space group number\n")
            return None
        if self.SG_num > 230 or self.SG_num < 1:
            self.log.WriteText("Entered space group number of "+str(self.SG_num) + " is invalid\n")
            return None
        if self.SG_num <= 230 and self.SG_num > 194:#cubic
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(False)
            self.text_ctrl_c.SetEditable(False)
            self.text_ctrl_alpha.SetEditable(False)
            self.text_ctrl_beta.SetEditable(False)
            self.text_ctrl_gamma.SetEditable(False)
        if self.SG_num < 195 and self.SG_num > 142:#hexagonal,trigonal
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(False)
            self.text_ctrl_c.SetEditable(True)
            self.text_ctrl_alpha.SetEditable(False)
            self.text_ctrl_beta.SetEditable(False)
            self.text_ctrl_gamma.SetEditable(False)
        if self.SG_num < 143 and self.SG_num > 74:#tetragonal
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(False)
            self.text_ctrl_c.SetEditable(True)
            self.text_ctrl_alpha.SetEditable(False)
            self.text_ctrl_beta.SetEditable(False)
            self.text_ctrl_gamma.SetEditable(False)
        if self.SG_num < 75 and self.SG_num > 15:#ortho
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(True)
            self.text_ctrl_c.SetEditable(True)
            self.text_ctrl_alpha.SetEditable(False)
            self.text_ctrl_beta.SetEditable(False)
            self.text_ctrl_gamma.SetEditable(False)
        if self.SG_num < 16 and self.SG_num > 2:#mono
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(True)
            self.text_ctrl_c.SetEditable(True)
            self.text_ctrl_alpha.SetEditable(False)
            self.text_ctrl_beta.SetEditable(True)
            self.text_ctrl_gamma.SetEditable(False)
        if self.SG_num < 3:#triclinic
            self.text_ctrl_a.SetEditable(True)
            self.text_ctrl_b.SetEditable(True)
            self.text_ctrl_c.SetEditable(True)
            self.text_ctrl_alpha.SetEditable(True)
            self.text_ctrl_beta.SetEditable(True)
            self.text_ctrl_gamma.SetEditable(True)
        
        self.SG_name = sgrp_name[str(self.SG_num)]
        self.label_SG_name.SetLabel(str(self.SG_name))
        self.update_lattice_params()

    def a_input(self, event):  # wxGlade: MyApp.<event_handler>
        if self.SG_num <= 230 and self.SG_num > 194:
            self.text_ctrl_b.SetValue(self.text_ctrl_a.GetValue())
            self.text_ctrl_c.SetValue(self.text_ctrl_a.GetValue())
        if self.SG_num < 195 and self.SG_num > 74:#hexagonal,trigonal,tetragonal,
            self.text_ctrl_b.SetValue(self.text_ctrl_a.GetValue())
        else:
            pass
        self.lattice_params = self.read_lattice()
#keeps the lattice param variable updated based on GUI input
    def alpha_input(self, event):  # wxGlade: MyApp.<event_handler>
        self.lattice_params = self.read_lattice()

    def b_input(self, event):  # wxGlade: MyApp.<event_handler>
        self.lattice_params = self.read_lattice()

    def beta_input(self, event):  # wxGlade: MyApp.<event_handler>
        self.lattice_params = self.read_lattice()

    def c_input(self, event):  # wxGlade: MyApp.<event_handler>
        self.lattice_params = self.read_lattice()

    def gamma_input(self, event):  # wxGlade: MyApp.<event_handler>
        self.lattice_params = self.read_lattice()

    def scale_input(self, event):  # wxGlade: MyApp.<event_handler>
        try:
            self.gaussian_params[0] = float(self.text_ctrl_scale.GetValue())
        except ValueError:
            self.log.WriteText("Enter a number\n")
    def sigma_input(self, event):  # wxGlade: MyApp.<event_handler>
        try:
            self.gaussian_params[1] = float(self.text_ctrl_sigma.GetValue())
        except ValueError:
            self.log.WriteText("Enter a number\n")
    def shift_input(self, event):  # wxGlade: MyApp.<event_handler>
        try:
            self.gaussian_params[2] = float(self.text_ctrl_shift.GetValue())
        except ValueError:
            self.log.WriteText("Enter a number\n")
    def input_max_ttheta(self, event):  # wxGlade: MyApp.<event_handler>
        try:
            self.max_2theta = float(self.text_ctrl_max_2theta.GetValue())
        except ValueError:
            self.log.WriteText("Enter a number\n")
    def fit_final_num_in(self, event):  # wxGlade: MyApp.<event_handler>
        try:
            self.max_dataframe = int(self.text_ctrl_final_file_num.GetValue())
        except ValueError:
            self.log.WriteText("Enter a number\n")
        
    def theta_variance2datapoints(self, event): #estimates number of data points which makes up the 2theta variance entered in the GUI
        try:
            window_2theta = float(self.text_ctrl_variance.GetValue())#read the GUI input
        except ValueError:
            self.log.WriteText("Enter a number\n")
            return None
        data_frame = open_dat(self.loaded_datafiles[0])#load in 1st dataset [[x,y],[x,y]....]
        x_values = [i[0] for i in data_frame]
        data_start = x_values[0]#1st x-value
        data_end = data_start + window_2theta#end point of the data window
        data_window = [x for x in x_values if x < data_end]
        window_datapoints = int(len(data_window)/2)
        self.fit_window_size = window_datapoints
         
    def do_seq_fit(self, event):  # the sequential fitting loop
    
    #list of datafiles:
        framelist = self.loaded_datafiles
        if framelist ==[]:
            self.log.WriteText("No datafiles loaded\n")
            return None
        self.gauge_1.SetRange(len(framelist))
        counter = int(0)
    #do indexing in order to determine number of peaks which is needed to create list of gaussians:
        #create local variable of lattice_params
        lattice_params = self.lattice_params
        if lattice_params == None or any(v == None or v == '' for v in lattice_params) or self.SG_num == False or self.SG_num == None:
            self.log.WriteText("Missing crystallographic parameters\n")
            return None
        #create material object from lattice params, SGLatiice object is not used here
        material, SGLattice_object = SG_lattice_params2material(int(self.SG_num), lattice_params)
        #indexing info is a dictionary of peaks, needs a material object
        if self.wavelength == None:
            self.log.WriteText("Missing wavelength\n")
            return None
        indexing_info = xu.simpack.PowderDiffraction(material, tt_cutoff = self.max_2theta, enable_simulation = False, wl = self.wavelength).data
        num_peaks = len(indexing_info.keys())
    #convert the self.gaussian_params object (which is just a list of scale, sigma, shift)
    #into a list of [scale, scale,... sigma, sigma,...  shift, shift,... per number of peaks]
        raw_gaussian_params = self.gaussian_params
        if any(g == 0  for g in raw_gaussian_params):
            self.log.WriteText("Missing, or zero value gaussian parameters\n")
            return None
        if self.fit_window_size == 0:
            self.log.WriteText("Fit window not specified\n")
            return None
        amps = [raw_gaussian_params[0]] * num_peaks
        sigmas = [raw_gaussian_params[1]] * num_peaks
        shifts = [raw_gaussian_params[2]] * num_peaks
        gaussian_params = amps + sigmas + shifts
        #make a backup file:
        out_file = "seq_backup.csv"
        self.log.WriteText("Created backup file: seq_backup.csv"+"\n")
        with open(out_file, mode = "w") as file:
            file.write("Filepath, Lattice parameters\n")
            file.close()
        #now the cyclic mode starts
        for frame in framelist:
            LS_params = list(gaussian_params)
            for i in lattice_params:
                LS_params.append(i)
            lower_bounds = [0 for i in LS_params]#hard coded bounds of 0 to +inf for all params
            upper_bounds = [np.inf for i in LS_params]
            bounds = Bounds(lb = lower_bounds, ub = upper_bounds)
            #do the LS
            try:
                LS_out = do_fit(fit_function, 
                                    LS_params, 
                                    bounds, 
                                    self.SG_num, 
                                    self.max_2theta, 
                                    self.wavelength, 
                                    frame, 
                                    int(self.fit_window_size), 
                                    num_peaks)
            except:
                self.log.WriteText("==== ERROR IN LEAST SQUARES ====\nConsidering changing starting parameters, reducing maximum 2theta for indexing, or the fitting window\n")
                break
            #redefine LS_params for next fit, conviently assign gaussians and lattice:
            if LS_params == list(LS_out.x):#LS minimiser has stopped working
                #originally was a function here to add some random noise to the LS parameters
                #this is likely not the best approach
                #the original error was due to a peak position crossing the 2theta indexing limit
                #the peak would then be ignored but the gaussian parameters would still be sent to the LS function
                #the LS function was rewritten to constrain the number of gaussian parameters based on the number of peaks
                
                self.log.WriteText("Refinement returned input values\n")
                self.log.WriteText("If fit continues to break at this point, check python console\n")
                self.log.WriteText("An out of bounds error likely means a peak is crossing the 2theta indexing limit\n")

            LS_params = LS_out.x
            out_gauss = LS_out.x[0:num_peaks*3]
            out_lattice_params = LS_out.x[num_peaks*3:]
            lattice_params = out_lattice_params
            gaussian_params = out_gauss
            #calculate volume
            out_volume = lattice2volume(self.SG_num, out_lattice_params)
            #write to log
            self.log.WriteText("Fitted: "+str(frame)+"\n")
            self.log.WriteText("With residual sum of: "+str(LS_out.cost)+"\n")
            self.log.WriteText("Refined gaussian parameters: "+str(out_gauss)+"\n")
            self.log.WriteText("Refined lattice parameters: "+str(out_lattice_params)+"\n")
            self.log.WriteText("Volume = "+str(out_volume)+"\n")
            #write data dictionary (used to be a custom class, but wasn't really necessary)
            out_data_object = {}
            out_data_object["filename"] = os.path.split(frame)[1]
            out_data_object["filepath"] = frame
            out_data_object["LS_gauss (scale sigma shift per peak"] = list(out_gauss)#need to reformat for file i/o
            #converts list (which will not format correctly in .csv) to string of space seperated values
            write_string = ""
            for value in out_data_object["LS_gauss (scale sigma shift per peak"]:
                write_string += str(value)
                write_string += " "
            out_data_object["LS_gauss (scale sigma shift per peak"] = write_string.strip("['")
            out_data_object["LS_gauss (scale sigma shift per peak"] = write_string.strip("']")
            #as above
            out_data_object["LS_lattice (variable length depending on symmetry)"] = list(out_lattice_params)#need to reformat for file i/o
            write_string = ""
            for value in out_data_object["LS_lattice (variable length depending on symmetry)"]:
                write_string += str(value)
                write_string += " "
            out_data_object["LS_lattice (variable length depending on symmetry)"] = write_string.strip("[")
            out_data_object["LS_lattice (variable length depending on symmetry)"] = write_string.strip("]")
            out_data_object["V (A^3)"] = out_volume
            out_data_object["P (GPa)"] = None
            out_data_object["T (K)"] = None
            out_data_object["LS cost value"] = LS_out.cost
            #add the dictionary to the main list
            self.refined_datasets.append(out_data_object)
            #write to backup file
            with open(out_file, mode = "a") as file:
                lattice_write = [i for i in LS_out.x[num_peaks*3:]]
                file.write(str(frame)+",")
                for i in lattice_write:
                    file.write(str(i)+",")
                    file.write("\n")
                file.close()
            PVT_table_list = [os.path.split(frame)[1], out_volume, "",""]
            counter += 1
            print("dataset "+str(counter)+" fit")
            #update GUI
            self.gauge_1.SetValue(counter)
            self.PVT_table.Append(PVT_table_list)
            self.Refresh()
            self.Update()
            #the GUI will be non responsive while this loops
            
    def do_seq_threaded(self,event):
        #opens new thread to keep GUI updating... but GUI still goes non-responsive if window is unfocused
        t = Thread(target=self.do_seq_fit, args=[event])
        t.run()

    def calibrant_load(self, event): #which inbuilt material to pass to PVT
        self.loaded_calibrant = self.CB_select_EoS_params.GetValue()
        self.selected_EoS_dict = [i for i in self.loaded_calibrant_dicts if i.get("name") == self.loaded_calibrant][-1]
        self.btn_do_PVT.Enable()
        
    def EoS_dialog(self, event):#spawn a dialog for user input of EoS params
        win = EoSDialog(self, 
                          style=wx.DEFAULT_FRAME_STYLE | wx.TINY_CAPTION)
        win.CenterOnParent(wx.BOTH)
        win.Show(True)
        
    def PVT_right_click(self, event):#spawn menu
        self.PopupMenu(PopMenu(self))
        
    def update_T(self, T):#case of user input of T
        table_index = list(range(self.PVT_table.GetFirstSelected(), self.PVT_table.GetFirstSelected() + self.PVT_table.GetSelectedItemCount(), 1))
        for i in table_index:
            self.PVT_table.SetItem(index =  i, column = 3, label = str(T))
            filename = self.PVT_table.GetItem(i).GetText()
            for data in self.refined_datasets:
                if filename == data["filename"]:
                    data["T (K)"] = T
                    
    def update_P(self,P):#case of user input of P
        table_index = list(range(self.PVT_table.GetFirstSelected(), self.PVT_table.GetFirstSelected() + self.PVT_table.GetSelectedItemCount(), 1))
        for i in table_index:
            self.PVT_table.SetItem(index =  i, column = 2, label = str(P))
            filename = self.PVT_table.GetItem(i).GetText()
            for data in self.refined_datasets:
                if filename == data["filename"]:
                    data["P (GPa)"] = P
                    
    def clearPT(self):#clear P & T values
        table_index = list(range(self.PVT_table.GetFirstSelected(), self.PVT_table.GetFirstSelected() + self.PVT_table.GetSelectedItemCount(), 1))
        for i in table_index:
            self.PVT_table.SetItem(index =  i, column = 2, label = "")
            self.PVT_table.SetItem(index =  i, column = 3, label = "")
            filename = self.PVT_table.GetItem(i).GetText()
            for data in self.refined_datasets:
                if filename == data["filename"]:
                    data["P (GPa)"] = None
                    data["T (K)"] = None
                    
    def do_PVT(self, event):#throw GUI values to PVT object, write output to data dictionary
        table_index = list(range(self.PVT_table.GetFirstSelected(), self.PVT_table.GetFirstSelected() + self.PVT_table.GetSelectedItemCount(), 1))
        for i in table_index:
            #initialise PVT list
            PVT_table = [None, None, None]
            #read PVT from dict into PVT list
            item = self.PVT_table.GetItem(i).GetText()
            volume = [i["V (A^3)"] for i in self.refined_datasets if i["filename"] == item][0]
            pressure = [i["P (GPa)"] for i in self.refined_datasets if i["filename"] == item][0]
            temperature = [i["T (K)"] for i in self.refined_datasets if i["filename"] == item][0]
            if pressure == None and temperature == None:
                self.log.WriteText("Missing P or T for list object: "+str(item)+"\n")
            if pressure != None:
                PVT_table[0] = float(pressure)
            if volume != None:
                PVT_table[1] = float(volume)
            if temperature != None:
                PVT_table[2] = float(temperature)
            #Do PVT calc
            PVT_object_out = BM(self.selected_EoS_dict, PVT_table)
            #update GUI
            P_out = PVT_object_out.P
            T_out = PVT_object_out.T
            self.log.WriteText("For datafile: "+str(item)+" P,T of "+str(P_out)+" GPa, "+str(T_out)+" K\n")
            self.PVT_table.SetItem(index =  i, column = 2, label = str(P_out))
            self.PVT_table.SetItem(index =  i, column = 3, label = str(T_out))
            #write PT values to dictionary: (Vs already set from LS)
            #this is kinda gross, if a differnt EoS equation is used it would need to be hard coded
            #ideally this would be dynamically generated from the dictionary keys
            #which in turn would be dynamically generated from the PVT object
            for dictionary in self.refined_datasets:
                if dictionary["filename"] == item:
                    dictionary["P (GPa)"] = P_out
                    dictionary["T (K)"] = T_out
            #adding thermodynamic parameters to data dictionary:
                    dictionary["Potential real pressure (bar)"] = PVT_object_out.p_x
                    dictionary["Thermal pressure (bar)"] = PVT_object_out.p_thermal
                    dictionary["Pressure(bar)"] = PVT_object_out.p_real
                    
                    dictionary["Internal energy (Jmol-1)"] = PVT_object_out.in_energy
                    dictionary["Gibbs energy (Jmol-1)"] = PVT_object_out.gibbs_energy
                    dictionary["Enthalpy (Jmol-1)"] = PVT_object_out.enthalpy
                    dictionary["Entropy (Jmol-1)"] = PVT_object_out.entropy
                    
                    dictionary["Helmholtz free energy (Jmol-1)"] = PVT_object_out.free_energy
                    dictionary["Potential Helmholtz free energy E298 (Jmol-1)"] = PVT_object_out.Ex
                    
                    dictionary["Isothermal bulk modulus (bar)"] = PVT_object_out.k_t
                    dictionary["Thermal isothermal bulk modulus (bar)"] = PVT_object_out.K_T_thermal
                    dictionary["Potential isothermal bulk modulus (bar)"] = PVT_object_out.KTx
                    dictionary["Adiabatic bulk modulus (bar)"] = PVT_object_out.Ks
                    
                    dictionary["Isochoric heat capacity (Jmol-1 K-1)"] = PVT_object_out.Cv
                    dictionary["Isobaric heat capacity (Jmol-1 K-1)"] = PVT_object_out.Cp
                    
                    dictionary["Compression"] = PVT_object_out.x
                    dictionary["Derivative dP/dT (bar K-1)"] = PVT_object_out.dPdT
                    dictionary["Volume cofficent of thermal expansivity (K-1 / 10-5 K-1)"] = PVT_object_out.alpha
                    dictionary["Einstein temperature multiplier"] = PVT_object_out.exp
                    dictionary["Thermodynamic Grunesisen"] = PVT_object_out.gamma
            
    
    def plot_PVT(self, event):#plot PVT
        #generate x and y datas
        x = list(range(len(self.refined_datasets)))
        P = []
        V = []
        T = []
        for dictionary in self.refined_datasets:
            if dictionary["P (GPa)"] != None:
                P.append(float(dictionary["P (GPa)"]))
            if dictionary["V (A^3)"] != None:
                V.append(float(dictionary["V (A^3)"]))
            if dictionary["T (K)"] != None:
                T.append(float(dictionary["T (K)"]))
                
            if dictionary["P (GPa)"] == None:
                P = [0 for i in x]
            if dictionary["V (A^3)"] == None:
                V = [0 for i in x]
            if dictionary["T (K)"] == None:
                T = [0 for i in x]
                
        #do plotting BS
        fig, ax = plt.subplots(3, 1, sharex = True, dpi = 100)
        fig.subplots_adjust(hspace = 0)

        ax[0].scatter(x, P, label = "Pressure")
        ax[0].set_ylabel("Pressure (GPa)")
        
        ax[1].scatter(x, V, label = "Volume")
        ax[1].set_ylabel("Volume (A^3)")
        
        ax[2].scatter(x, T, label = "Temperature")
        ax[2].set_xlabel("Dataset Number (n)")
        ax[2].set_ylabel("Temperature (K)")
        self.spawn_plot(fig, "PVT")
    
    def save_PVT(self, event):#save PVT
        wildcard = "csv file (*.csv)|*.csv|"     \
           "All files (*.*)|*.*"
        dlg = wx.FileDialog(
            self, message="Save file as ...", defaultDir=os.getcwd(),
            defaultFile="", wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            with open(path, mode = "w") as file:
                for i in list(self.refined_datasets[0].keys()):#creates a header from data dictionary
                    file.write(str(i)+",")
                file.write("\n")#new line after header
                for dictionary in self.refined_datasets:
                    for value in list(dictionary.values()):
                        file.write(str(value)+",")
                    file.write("\n")
                file.close()
            self.log.WriteText("Saved file: "+str(path))
        dlg.Destroy()
        
class PopMenu(wx.Menu):
 #little menu that pops up when list is right-clicked
    def __init__(self, parent):
        super(PopMenu, self).__init__()
 
        self.parent = parent
        popmenu_temperature = wx.MenuItem(self, wx.ID_ANY, 'Set Temperature')
        item1 = self.Append(popmenu_temperature)
        
        popmenu_pressure = wx.MenuItem(self, wx.ID_ANY, 'Set Pressure')
        item2 = self.Append(popmenu_pressure)
        
        popmenu_plot = wx.MenuItem(self, wx.ID_ANY, 'Plot fit')
        item3 = self.Append(popmenu_plot)
        
        popmenu_clear = wx.MenuItem(self, wx.ID_ANY, 'Clear P,T')
        item4 = self.Append(popmenu_clear)
        self.Bind(wx.EVT_MENU, self.temperature_edit, item1)
        self.Bind(wx.EVT_MENU, self.pressure_edit, item2)
        self.Bind(wx.EVT_MENU, self.plot_LS, item3)
        self.Bind(wx.EVT_MENU, self.clearPT, item4)
        
    def temperature_edit(self, event):
        dlg = wx.TextEntryDialog(
                self.parent, 'Set temperature for '+str(self.parent.PVT_table.GetSelectedItemCount())+" items",
                'Temperature (K)')

        if dlg.ShowModal() == wx.ID_OK:
            write_temperature = float(dlg.GetValue())
            self.parent.update_T(write_temperature)
        dlg.Destroy()
        
        
    def pressure_edit(self, event):
        dlg = wx.TextEntryDialog(
                self.parent, 'Set pressure for '+str(self.parent.PVT_table.GetSelectedItemCount())+" items",
                'Pressure (GPa)')

        if dlg.ShowModal() == wx.ID_OK:
            write_pressure = float(dlg.GetValue())
            self.parent.update_P(write_pressure)
        dlg.Destroy()
        
    def plot_LS(self, event): 
        i = self.parent.PVT_table.GetFocusedItem()
        item = self.parent.PVT_table.GetItem(i).GetText()
        for dictionary in self.parent.refined_datasets:
            if dictionary["filename"] == item:
                data_path = dictionary["filepath"]
                gauss_params = dictionary["LS_gauss (scale sigma shift per peak"]
                gauss_params = gauss_params.split(" ")
                gauss_params = [float(x) for x in gauss_params if x != ""]
                crystal_params = dictionary["LS_lattice (variable length depending on symmetry)"]
                crystal_params = crystal_params.split(" ")
                crystal_params = [float(x) for x in crystal_params if x != ""]
        parameters = gauss_params + crystal_params
        material = xu.materials.Crystal("material", xu.materials.SGLattice(int(self.parent.SG_num), *[float(i) for i in crystal_params]))
        indexing_info = xu.simpack.PowderDiffraction(material, tt_cutoff = self.parent.max_2theta, enable_simulation = False, wl = self.parent.wavelength).data
        num_peaks = len(indexing_info.keys())
        fig = plot_fit_function(parameters, self.parent.SG_num, self.parent.max_2theta, self.parent.wavelength, data_path, int(self.parent.fit_window_size),num_peaks)
        self.parent.spawn_plot(fig, name = str("Fit for "+item))
        
    def clearPT(self, event):
        self.parent.clearPT()

class EoSDialog(wx.Dialog):
    #ideally make something that can open a JCPDS
    def __init__(self, parent, *args, **kwds):
        # begin wxGlade: MyDialog.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, parent,*args, **kwds)
        self.loaded_calibrant = parent.loaded_calibrant
        self.parent = parent
        
        self.SetTitle("Edit Equation of State Parameters")

        sizer_1 = wx.BoxSizer(wx.VERTICAL)

        grid_sizer_1 = wx.FlexGridSizer(11, 6, 2, 2)
        sizer_1.Add(grid_sizer_1, 1, wx.ALL | wx.EXPAND, 2)

        self.label_7 = wx.StaticText(self, wx.ID_ANY, "Equation of State Parameters")
        grid_sizer_1.Add(self.label_7, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_27 = wx.StaticText(self, wx.ID_ANY, "Thermal EoS Parameters")
        grid_sizer_1.Add(label_27, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_8 = wx.StaticText(self, wx.ID_ANY, "Reference Energy (Jmol-1)")
        grid_sizer_1.Add(label_8, 0, 0, 0)

        self.text_ctrl_Uo = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Uo, 0, 0, 0)

        label_18 = wx.StaticText(self, wx.ID_ANY, u"Generalised Grüneisen parameter")
        grid_sizer_1.Add(label_18, 0, 0, 0)

        self.text_ctrl_t = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_t, 0, 0, 0)

        label_28 = wx.StaticText(self, wx.ID_ANY, u"𝛼 (10−5 K−1)")
        grid_sizer_1.Add(label_28, 0, 0, 0)

        self.text_ctrl_Therm_alpha_298 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Therm_alpha_298, 0, 0, 0)

        label_9 = wx.StaticText(self, wx.ID_ANY, "Atoms per formula unit (n)")
        grid_sizer_1.Add(label_9, 0, 0, 0)

        self.text_ctrl_n = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_n, 0, 0, 0)

        label_19 = wx.StaticText(self, wx.ID_ANY, u"Intrinsic anharmonicity parameter (10−6 K−1)")
        grid_sizer_1.Add(label_19, 0, 0, 0)

        self.text_ctrl_ao = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_ao, 0, 0, 0)

        label_29 = wx.StaticText(self, wx.ID_ANY, u"∂𝛼𝑇/∂𝑇 (10-8 K-2)")
        grid_sizer_1.Add(label_29, 0, 0, 0)

        self.text_ctrl_Therm_diff_alpha = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Therm_diff_alpha, 0, 0, 0)

        label_10 = wx.StaticText(self, wx.ID_ANY, u"Volume at ambient (Å3)")
        grid_sizer_1.Add(label_10, 0, 0, 0)

        self.text_ctrl_Vo = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Vo, 0, 0, 0)

        label_20 = wx.StaticText(self, wx.ID_ANY, u"Free electrons parameter (10−6 K−1)")
        grid_sizer_1.Add(label_20, 0, 0, 0)

        self.text_ctrl_eo = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_eo, 0, 0, 0)

        label_30 = wx.StaticText(self, wx.ID_ANY, u"∂𝐾0/∂𝑇 (GPa K-1)")
        grid_sizer_1.Add(label_30, 0, 0, 0)

        self.text_ctrl_Therm_diff_temp = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Therm_diff_temp, 0, 0, 0)

        label_11 = wx.StaticText(self, wx.ID_ANY, "Isothermal Bulk Modulus (GPa)")
        grid_sizer_1.Add(label_11, 0, 0, 0)

        self.text_ctrl_Ko = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Ko, 0, 0, 0)

        label_21 = wx.StaticText(self, wx.ID_ANY, u"Anharmonic analogue of the Grüneisen parameter")
        grid_sizer_1.Add(label_21, 0, 0, 0)

        self.text_ctrl_m = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_m, 0, 0, 0)

        label_31 = wx.StaticText(self, wx.ID_ANY, u"∂𝐾′/∂𝑇 (K-1)")
        grid_sizer_1.Add(label_31, 0, 0, 0)

        self.text_ctrl_Therm_diff_Kprime = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Therm_diff_Kprime, 0, 0, 0)

        label_12 = wx.StaticText(self, wx.ID_ANY, "K'")
        grid_sizer_1.Add(label_12, 0, 0, 0)

        self.text_ctrl_kprime = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_kprime, 0, 0, 0)

        label_22 = wx.StaticText(self, wx.ID_ANY, u"Electronic analogue of the Grüneisen parameter")
        grid_sizer_1.Add(label_22, 0, 0, 0)

        self.text_ctrl_g = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_g, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_13 = wx.StaticText(self, wx.ID_ANY, u"Einstein Θ1 (K)")
        grid_sizer_1.Add(label_13, 0, 0, 0)

        self.text_ctrl_QE1 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_QE1, 0, 0, 0)

        label_23 = wx.StaticText(self, wx.ID_ANY, "c0 Parameter of the Holzapfel EoS")
        grid_sizer_1.Add(label_23, 0, 0, 0)

        self.text_ctrl_co = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_co, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_14 = wx.StaticText(self, wx.ID_ANY, "Einstein number 1")
        grid_sizer_1.Add(label_14, 0, 0, 0)

        self.text_ctrl_m1 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_m1, 0, 0, 0)

        label_24 = wx.StaticText(self, wx.ID_ANY, "c2 Parameter of the Holzapfel EoS")
        grid_sizer_1.Add(label_24, 0, 0, 0)

        self.text_ctrl_c2 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_c2, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_15 = wx.StaticText(self, wx.ID_ANY, u"Einstein Θ2 (K)")
        grid_sizer_1.Add(label_15, 0, 0, 0)

        self.text_ctrl_QE2 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_QE2, 0, 0, 0)

        label_25 = wx.StaticText(self, wx.ID_ANY, "Temperature of the reference isotherm (K)")
        grid_sizer_1.Add(label_25, 0, 0, 0)

        self.text_ctrl_To = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_To, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_16 = wx.StaticText(self, wx.ID_ANY, "Einstein number 2")
        grid_sizer_1.Add(label_16, 0, 0, 0)

        self.text_ctrl_m2 = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_m2, 0, 0, 0)

        label_26 = wx.StaticText(self, wx.ID_ANY, "Average atomic number Z")
        grid_sizer_1.Add(label_26, 0, 0, 0)

        self.text_ctrl_Z = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_Z, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        label_17 = wx.StaticText(self, wx.ID_ANY, u"δ Additive normalising constant")
        grid_sizer_1.Add(label_17, 0, 0, 0)

        self.text_ctrl_delta = wx.TextCtrl(self, wx.ID_ANY, "")
        grid_sizer_1.Add(self.text_ctrl_delta, 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)

        grid_sizer_1.Add((0, 0), 0, 0, 0)
        
        sizer_2 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_1.Add(sizer_2, 0,0,0)
        
        self.button_LOAD = wx.Button(self, wx.ID_ANY, "Load from .eos")
        self.button_LOAD.SetDefault()
        sizer_2.Add(self.button_LOAD)
        
        self.button_SAVE = wx.Button(self, wx.ID_SAVE, "Save to .eos")
        self.button_SAVE.SetDefault()
        sizer_2.Add(self.button_SAVE)

        sizer_3 = wx.StdDialogButtonSizer()
        sizer_1.Add(sizer_3, 0, wx.ALIGN_RIGHT | wx.ALL, 4)
        
        

        self.button_OK = wx.Button(self, wx.ID_OK, "")
        self.button_OK.SetDefault()
        sizer_3.AddButton(self.button_OK)

        self.button_CANCEL = wx.Button(self, wx.ID_CANCEL, "")
        sizer_3.AddButton(self.button_CANCEL)

        sizer_3.Realize()

        self.SetSizer(sizer_1)
        sizer_1.Fit(self)

        self.SetAffirmativeId(self.button_OK.GetId())
        self.SetEscapeId(self.button_CANCEL.GetId())

        self.Layout()
        
        self.Bind(wx.EVT_BUTTON, self.OK, self.button_OK)
        self.Bind(wx.EVT_BUTTON, self.load, self.button_LOAD)
        self.Bind(wx.EVT_BUTTON, self.save, self.button_SAVE)
        
        if self.loaded_calibrant in [i.get("name") for i in EoS.dictionaries]:
            self.label_7.SetLabel("Equation of State Parameters for "+str(self.loaded_calibrant))
            self.EoS_params = [i for i in EoS.dictionaries if self.loaded_calibrant == i.get("name")][0]
            self.text_ctrl_Uo.SetValue(str(self.EoS_params.get("U_0")))
            self.text_ctrl_n.SetValue(str(self.EoS_params["n"]))
            self.text_ctrl_Vo.SetValue(str(self.EoS_params["V_0"]))
            self.text_ctrl_Ko.SetValue(str(self.EoS_params["K_0"]))
            self.text_ctrl_kprime.SetValue(str(self.EoS_params["K_prime"]))
            self.text_ctrl_QE1.SetValue(str(self.EoS_params["theta_1"]))
            self.text_ctrl_m1.SetValue(str(self.EoS_params["Ein_1"]))
            self.text_ctrl_QE2.SetValue(str(self.EoS_params["theta_2"]))
            self.text_ctrl_m2.SetValue(str(self.EoS_params["Ein_2"]))
            self.text_ctrl_delta.SetValue(str(self.EoS_params["delta"]))
            self.text_ctrl_t.SetValue(str(self.EoS_params["t"]))
            self.text_ctrl_ao.SetValue(str(self.EoS_params["a_0"]))
            self.text_ctrl_eo.SetValue(str(self.EoS_params["e_0"]))
            self.text_ctrl_m.SetValue(str(self.EoS_params["m"]))
            self.text_ctrl_g.SetValue(str(self.EoS_params["g"]))
            self.text_ctrl_co.SetValue(str(self.EoS_params["c_0"]))
            self.text_ctrl_c2.SetValue(str(self.EoS_params["c_2"]))
            self.text_ctrl_To.SetValue(str(self.EoS_params["T_0"]))
            self.text_ctrl_Z.SetValue(str(self.EoS_params["Z"]))
            self.text_ctrl_Therm_alpha_298.SetValue(str(self.EoS_params["Therm_alpha_298"]))
            self.text_ctrl_Therm_diff_temp.SetValue(str(self.EoS_params["Therm_diff_temp"]))
            self.text_ctrl_Therm_diff_alpha.SetValue(str(self.EoS_params["Therm_diff_alpha"]))
            self.text_ctrl_Therm_diff_Kprime.SetValue(str(self.EoS_params["Therm_diff_Kprime"]))
        
    def load(self, event):
        wildcard = "EoS file (*.eos)|*.eos|"     \
           "All files (*.*)|*.*"
        dlg = wx.FileDialog(
            self, message="Choose .eos file",
            defaultDir=os.getcwd(),
            defaultFile="",
            wildcard=wildcard,
            style=wx.FD_OPEN |
                  wx.FD_CHANGE_DIR | wx.FD_FILE_MUST_EXIST |
                  wx.FD_PREVIEW
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPaths()[0]
            with open(path, mode = "r") as file:
                for line in file:
                    file_buffer.append(line)
                file.close()
            keys = [i.split("=")[0] for i in file_buffer]
            keys = [i.strip(" ") for i in keys]
        
            values = [i.split("=")[1] for i in file_buffer]
            values = [i.strip("\n") for i in values]
            values = [i.strip(" ")for i in values]
            self.loaded_calibrant = values[0]
        
            self.EoS_params = dict(zip(keys, values))
            self.label_7.SetLabel("Equation of State Parameters for "+str(self.loaded_calibrant))
            self.text_ctrl_Uo.SetValue(str(self.EoS_params.get("U_0")))
            self.text_ctrl_n.SetValue(str(self.EoS_params["n"]))
            self.text_ctrl_Vo.SetValue(str(self.EoS_params["V_0"]))
            self.text_ctrl_Ko.SetValue(str(self.EoS_params["K_0"]))
            self.text_ctrl_kprime.SetValue(str(self.EoS_params["K_prime"]))
            self.text_ctrl_QE1.SetValue(str(self.EoS_params["theta_1"]))
            self.text_ctrl_m1.SetValue(str(self.EoS_params["Ein_1"]))
            self.text_ctrl_QE2.SetValue(str(self.EoS_params["theta_2"]))
            self.text_ctrl_m2.SetValue(str(self.EoS_params["Ein_2"]))
            self.text_ctrl_delta.SetValue(str(self.EoS_params["delta"]))
            self.text_ctrl_t.SetValue(str(self.EoS_params["t"]))
            self.text_ctrl_ao.SetValue(str(self.EoS_params["a_0"]))
            self.text_ctrl_eo.SetValue(str(self.EoS_params["e_0"]))
            self.text_ctrl_m.SetValue(str(self.EoS_params["m"]))
            self.text_ctrl_g.SetValue(str(self.EoS_params["g"]))
            self.text_ctrl_co.SetValue(str(self.EoS_params["c_0"]))
            self.text_ctrl_c2.SetValue(str(self.EoS_params["c_2"]))
            self.text_ctrl_To.SetValue(str(self.EoS_params["T_0"]))
            self.text_ctrl_Z.SetValue(str(self.EoS_params["Z"]))
            self.text_ctrl_Therm_alpha_298.SetValue(str(self.EoS_params["Therm_alpha_298"]))
            self.text_ctrl_Therm_diff_temp.SetValue(str(self.EoS_params["Therm_diff_temp"]))
            self.text_ctrl_Therm_diff_alpha.SetValue(str(self.EoS_params["Therm_diff_alpha"]))
            self.text_ctrl_Therm_diff_Kprime.SetValue(str(self.EoS_params["Therm_diff_Kprime"]))
        else:
            self.parent.log.Write("Please select a valid file")
        dlg.Destroy()
        file_buffer = []
        
    
    def save(self, event):
        wildcard = "EoS file (*.eos)|*.eos|"     \
           "All files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Save file as ...", defaultDir=os.getcwd(),
            defaultFile="", wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            with open(path, mode = "w") as file:
                file.write("name = "+str(os.path.split(path)[1].split(".")[0])+"\n")
                file.write("U_0 = "+str(self.text_ctrl_Uo.GetValue())+"\n")
                file.write("n = "+str(self.text_ctrl_n.GetValue())+"\n")
                file.write("V_0 ="+str(self.text_ctrl_Vo.GetValue())+"\n")
                file.write("K_0 = "+str(self.text_ctrl_Ko.GetValue())+"\n")
                file.write("K_prime = "+str(self.text_ctrl_kprime.GetValue())+"\n")
                file.write("theta_1 = "+str(self.text_ctrl_QE1.GetValue())+"\n")
                file.write("Ein_1 = "+str(self.text_ctrl_m1.GetValue())+"\n")
                file.write("theta_2 = "+str(self.text_ctrl_QE2.GetValue())+"\n")
                file.write("Ein_2 = "+str(self.text_ctrl_m2.GetValue())+"\n")
                file.write("delta = "+str(self.text_ctrl_delta.GetValue())+"\n")
                file.write("t = "+str(self.text_ctrl_t.GetValue())+"\n")
                file.write("a_0 = "+str(self.text_ctrl_ao.GetValue())+"\n")
                file.write("e_0 = "+str(self.text_ctrl_eo.GetValue())+"\n")
                file.write("m = "+str(self.text_ctrl_m.GetValue())+"\n")
                file.write("g = "+str(self.text_ctrl_g.GetValue())+"\n")
                file.write("c_0 = "+str(self.text_ctrl_co.GetValue())+"\n")
                file.write("c_2 = "+str(self.text_ctrl_c2.GetValue())+"\n")
                file.write("T_0 = "+str(self.text_ctrl_To.GetValue())+"\n")
                file.write("Z = "+str(self.text_ctrl_Z.GetValue())+"\n")
                file.write("Therm_alpha_298 = "+str(self.text_ctrl_Therm_alpha_298.GetValue())+"\n")
                file.write("Therm_diff_temp = "+str(self.text_ctrl_Therm_diff_temp.GetValue())+"\n")
                file.write("Therm_diff_alpha = "+str(self.text_ctrl_Therm_diff_alpha.GetValue())+"\n")
                file.write("Therm_diff_Kprime = "+str(self.text_ctrl_Therm_diff_Kprime.GetValue())+"\n")
                file.close()
        dlg.Destroy()
        
        
        
    def OK(self, event):
        self.parent.loaded_calibrant = self.loaded_calibrant
        self.EoS_params = {}
        self.EoS_params["name"] = self.loaded_calibrant
        self.EoS_params["U_0"] = float(self.text_ctrl_Uo.GetValue())
        self.EoS_params["n"] = float(self.text_ctrl_n.GetValue())
        self.EoS_params["V_0"] = float(self.text_ctrl_Vo.GetValue())
        self.EoS_params["K_0"] = float(self.text_ctrl_Ko.GetValue())
        self.EoS_params["K_prime"] = float(self.text_ctrl_kprime.GetValue())
        self.EoS_params["theta_1"] = float(self.text_ctrl_QE1.GetValue())
        self.EoS_params["Ein_1"] = float(self.text_ctrl_m1.GetValue())
        self.EoS_params["theta_2"] = float(self.text_ctrl_QE2.GetValue())
        self.EoS_params["Ein_2"] = float(self.text_ctrl_m2.GetValue())
        self.EoS_params["delta"] = float(self.text_ctrl_delta.GetValue())
        self.EoS_params["t"] = float(self.text_ctrl_t.GetValue())
        self.EoS_params["a_0"] = float(self.text_ctrl_ao.GetValue())
        self.EoS_params["e_0"] = float(self.text_ctrl_eo.GetValue())
        self.EoS_params["m"] = float(self.text_ctrl_m.GetValue())
        self.EoS_params["g"] = float(self.text_ctrl_g.GetValue())
        self.EoS_params["c_0"] = float(self.text_ctrl_co.GetValue())
        self.EoS_params["c_2"] = float(self.text_ctrl_c2.GetValue())
        self.EoS_params["T_0"] = float(self.text_ctrl_To.GetValue())
        self.EoS_params["Z"] = float(self.text_ctrl_Z.GetValue())
        self.EoS_params["Therm_alpha_298"] = float(self.text_ctrl_Therm_alpha_298.GetValue())
        self.EoS_params["Therm_diff_temp"] = float(self.text_ctrl_Therm_diff_temp.GetValue())
        self.EoS_params["Therm_diff_alpha"] = float(self.text_ctrl_Therm_diff_alpha.GetValue())
        self.EoS_params["Therm_diff_Kprime"] = float(self.text_ctrl_Therm_diff_Kprime.GetValue())
        self.parent.CB_select_EoS_params.AppendItems(self.loaded_calibrant)
        self.parent.CB_select_EoS_params.SetStringSelection(self.loaded_calibrant)
        self.parent.loaded_calibrant_dicts.append(self.EoS_params)
        self.Close(True)
        self.Destroy()
        pass
    
    def OnCloseMe(self, event):
        self.Close(True)

    def OnCloseWindow(self, event):
        self.Destroy()
    

class MyCanvasPanel(wx.Panel):
    def __init__(self, parent, fig):
        wx.Panel.__init__(self, parent)
        self.fig = fig
        self.CreateCtrls()
        self.DoLayout()
    def CreateCtrls(self):
        self.figure = self.fig
        self.canvas = FigureCanvas(self, -1, self.figure)
        self.toolbar = NavigationToolbar2Wx(self.canvas)
        self.toolbar.Realize()
    def DoLayout(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
        sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
        self.SetSizer(sizer)
        self.Fit()
        
class Plotframe(wx.Frame):
    def __init__(self, parent, title, fig):
        wx.Frame.__init__(self, parent, id=wx.ID_ANY,
                          title = title,
                          size=(700, 700))
        self.panel = MyCanvasPanel(self, fig)
        
class MyApp(wx.App):
    def OnInit(self):
        self.frame = Main_window(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame)
        self.frame.Show()
        return True

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
